<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CSS Pseudo Class</title>
    <link rel="stylesheet" href=".\resources\css\index.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Libre+Franklin:ital,wght@0,400;0,700;1,400&family=Merriweather:ital,wght@0,400;0,700;1,400&display=swap" rel="stylesheet">
</head>
<body>
    <!--Header Section-->
    <div class="banner">
        <h1>CSS Pseudo-Classes Cheat Sheet</h1>
    </div>

    <!--Table Section Element display state -->
    <h2>Element display state Pseudo-Class</h2>
    <table>
        <thead>
            <tr>
                <th class="leftColumn">Name</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td class="leftColumn">:fullscreen</td>
                <td>Matches an element that is currently in fullscreen mode.</td>
            </tr>
            <tr>
                <td class="leftColumn">:modal</td>
                <td>Matches an element that is in a state in which it excludes all interaction with elements outside it until the interaction has been dismissed.</td>
            </tr>
            <tr>
                <td class="lastLeft">:picture-in-picture</td>
                <td class="lastRight">Matches an element that is currently in picture-in-picture mode.</td>
            </tr>
        </tbody>
    </table>

    <!--Table Section Input -->
    <h2>Input Pseudo-Class</h2>
    <table>
        <thead>
            <tr>
                <th class="leftColumn">Name</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td class="leftColumn">:autofill</td>
                <td>Matches when an &lt;input&gt; has been autofilled by the browser.</td>
            </tr>
            <tr>
                <td class="leftColumn">:enabled</td>
                <td>Represents a user interface element that is in an enabled state.</td>
            </tr>
            <tr>
                <td class="leftColumn">:disabled</td>
                <td>Represents a user interface element that is in a disabled state.</td>
            </tr>
            <tr>
                <td class="leftColumn">:read-only</td>
                <td>Represents any element that cannot be changed by the user.</td>
            </tr>
            <tr>
                <td class="leftColumn">:read-write</td>
                <td>Represents any element that is user-editable.</td>
            </tr>
            <tr>
                <td class="leftColumn">:placeholder-shown</td>
                <td>Matches an input element that is displaying placeholder text. For example, it will match the placeholder attribute in the &lt;input&gt; and &lt;textarea&gt; elements.</td>
            </tr>
            <tr>
                <td class="leftColumn">:default</td>
                <td>Matches one or more UI elements that are the default among a set of elements.</td>
            </tr>
            <tr>
                <td class="leftColumn">:checked</td>
                <td>Matches when elements such as checkboxes and radio buttons are toggled on.</td>
            </tr>
            <tr>
                <td class="leftColumn">:indeterminate</td>
                <td>Matches UI elements when they are in an indeterminate state.</td>
            </tr>
            <tr>
                <td class="leftColumn">:blank</td>
                <td>Matches a user-input element which is empty, containing an empty string or other null input.</td>
            </tr>
            <tr>
                <td class="leftColumn">:valid</td>
                <td>Matches an element with valid contents. For example, an input element with the type 'email' that contains a validly formed email address or an empty value if the control is not required.</td>
            </tr>
            <tr>
                <td class="leftColumn">:invalid</td>
                <td>Matches an element with invalid contents. For example, an input element with type 'email' with a name entered.</td>
            </tr>
            <tr>
                <td class="leftColumn">:in-range</td>
                <td>Applies to elements with range limitations. For example, a slider control when the selected value is in the allowed range.</td>
            </tr>
            <tr>
                <td class="leftColumn">:out-of-range</td>
                <td>Applies to elements with range limitations. For example, a slider control when the selected value is outside the allowed range.</td>
            </tr>
            <tr>
                <td class="leftColumn">:required</td>
                <td>Matches when a form element is required.</td>
            </tr>
            <tr>
                <td class="leftColumn">:optional</td>
                <td>Matches when a form element is optional.</td>
            </tr>
            <tr>
                <td class="leftColumn">:user-valid</td>
                <td>Represents an element with correct input, but only when the user has interacted with it.</td>
            </tr>
            <tr>
                <td class="lastLeft">:user-invalid</td>
                <td class="lastRight">Represents an element with incorrect input, but only when the user has interacted with it.</td>
            </tr>
        </tbody>
    </table>

    <!--Table Section Linguistic -->
  <h2>Linguistic Pseudo-Class</h2>
    <table>
        <thead>
            <tr>
                <th class="leftColumn">Name</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td class="leftColumn">:dir()</td>
                <td>The directionality pseudo-class selects an element based on its directionality as determined by the document language.</td>
            </tr>
            <tr>
                <td class="lastLeft">:lang()</td>
                <td class="lastRight">Select an element based on its content language.</td>
            </tr>
        </tbody>
    </table>

    <!--Table Section Location -->
  <h2>Location Pseudo-Class</h2>
    <table>
        <thead>
            <tr>
                <th class="leftColumn">Name</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td class="leftColumn">:any-link</td>
                <td>Matches an element if the element would match either <span class="blueText">:link</span> or <span class="blueText">:visited</span>.</td>
            </tr>
            <tr>
                <td class="leftColumn">:link</td>
                <td>Matches links that have not yet been visited.</td>
            </tr>
            <tr>
                <td class="leftColumn">:visited</td>
                <td>Matches links that have been visited.</td>
            </tr>
            <tr>
                <td class="leftColumn">:local-link</td>
                <td>Matches links whose absolute URL is the same as the target URL. For example, anchor links to the same page.</td>
            </tr>
            <tr>
                <td class="leftColumn">:target</td>
                <td>Matches the element which is the target of the document URL.</td>
            </tr>
            <tr>
                <td class="leftColumn">:target-within</td>
                <td>Matches elements which are the target of the document URL, but also elements which have a descendant which is the target of the document URL.</td>
            </tr>
            <tr>
                <td class="lastLeft">:scope</td>
                <td class="lastRight">Represents elements that are a reference point for selectors to match against.</td>
            </tr>
        </tbody>
    </table>

    <!--Table Section Resource state -->
  <h2>Resource state Pseudo-Class</h2>
    <table>
        <thead>
            <tr>
                <th class="leftColumn">Name</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td class="leftColumn">:playing</td>
                <td>Represents a media element that is capable of playing when that element is playing.</td>
            </tr>
            <tr>
                <td class="lastLeft">:paused</td>
                <td class="lastRight">Represents a media element that is capable of playing when that element is paused.</td>
            </tr>
        </tbody>
    </table>

    <!--Table Section Time-dimensional -->
  <h2>Time-dimensional Pseudo-Class</h2>
    <table>
        <thead>
            <tr>
                <th class="leftColumn">Name</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td class="leftColumn">:current</td>
                <td>Represents the element or ancestor of the element that is being displayed.</td>
            </tr>
            <tr>
                <td class="leftColumn">:past</td>
                <td>Represents an element that occurs entirely before the <span class="blueText">:current</span> element.</td>
            </tr>
            <tr>
                <td class="lastLeft">:future</td>
                <td class="lastRight">Represents an element that occurs entirely after the <span class="blueText">:current</span> element.</td>
            </tr>
        </tbody>
    </table>
    
    <!--Table Section Tree-structural -->
    <h2>Tree-structural Pseudo-Class</h2>
    <table>
        <thead>
            <tr>
                <th class="leftColumn">Name</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td class="leftColumn">:root</td>
                <td>Represents an element that is the root of the document. In HTML this is usually the &lt;html&gt; element.</td>
            </tr>
            <tr>
                <td class="leftColumn">:empty</td>
                <td>Represents an element with no children other than white-space characters.</td>
            </tr>
            <tr>
                <td class="leftColumn">:nth-child</td>
                <td>Uses An+B notation to select elements from a list of sibling elements.</td>
            </tr>
            <tr>
                <td class="leftColumn">:nth-last-child</td>
                <td>Uses An+B notation to select elements from a list of sibling elements, counting backwards from the end of the list.</td>
            </tr>
            <tr>
                <td class="leftColumn">:first-child</td>
                <td>Matches an element that is the first of its siblings.</td>
            </tr>
            <tr>
                <td class="leftColumn">:last-child</td>
                <td>Matches an element that is the last of its siblings.</td>
            </tr>
            <tr>
                <td class="leftColumn">:only-child</td>
                <td>Matches an element that has no siblings. For example, a list item with no other list items in that list.</td>
            </tr>
            <tr>
                <td class="leftColumn">:nth-of-type</td>
                <td>Uses An+B notation to select elements from a list of sibling elements that match a certain type from a list of sibling elements.</td>
            </tr>
            <tr>
                <td class="leftColumn">:nth-last-of-type</td>
                <td>Uses An+B notation to select elements from a list of sibling elements that match a certain type from a list of sibling elements counting backwards from the end of the list.</td>
            </tr>
            <tr>
                <td class="leftColumn">:first-of-type</td>
                <td>Matches an element that is the first of its siblings, and also matches a certain type selector.</td>
            </tr>
            <tr>
                <td class="leftColumn">:last-of-type</td>
                <td>Matches an element that is the last of its siblings, and also matches a certain type selector.</td>
            </tr>
            <tr>
                <td class="lastLeft">:only-of-type</td>
                <td class="lastRight">Matches an element that has no siblings of the chosen type selector.</td>
            </tr>
        </tbody>
    </table>

    <!--Table Section User action -->
    <h2>User action Pseudo-Class</h2>
    <table>
        <thead>
            <tr>
                <th class="leftColumn">Name</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td class="leftColumn">:hover</td>
                <td>Matches when a user designates an item with a pointing device, such as holding the mouse pointer over the item.</td>
            </tr>
            <tr>
                <td class="leftColumn">:active</td>
                <td>Matches when an item is being activated by the user. For example, when the item is clicked on.</td>
            </tr>
            <tr>
                <td class="leftColumn">:focus</td>
                <td>Matches when an element has focus.</td>
            </tr>
            <tr>
                <td class="leftColumn">:focus-visible</td>
                <td>Matches when an element has focus and the user agent identifies that the element should be visibly focused.</td>
            </tr>
            <tr>
                <td class="lastLeft">:focus-within</td>
                <td class="lastRight">Matches an element to which <span class="blueText">:focus</span> applies, plus any element that has a descendant to which <span class="blueText">:focus</span> applies.</td>
            </tr>
        </tbody>
    </table>

    <!--Table Section Functional -->
    <h2>Functional Pseudo-Class</h2>
    <table>
        <thead>
            <tr>
                <th class="leftColumn">Name</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td class="leftColumn">:is()</td>
                <td>The matches-any pseudo-class matches any element that matches any of the selectors in the list provided. The list is forgiving.</td>
            </tr>
            <tr>
                <td class="leftColumn">:not()</td>
                <td>The negation, or matches-none, pseudo-class represents any element that is not represented by its argument.</td>
            </tr>
            <tr>
                <td class="leftColumn">:where()</td>
                <td>The specificity-adjustment pseudo-class matches any element that matches any of the selectors in the list provided without adding any specificity weight. The list is forgiving.</td>
            </tr>
            <tr>
                <td class="lastLeft">:has()</td>
                <td class="lastRight">The relational pseudo-class represents an element if any of the relative selectors match when anchored against the attached element.</td>
            </tr>
        </tbody>
    </table>

    <!--Footer Section-->
    <div class="footer">
      <p>Created by: <br>Anton Romchuk, 2024</p>
    </div>
</body>
</html>